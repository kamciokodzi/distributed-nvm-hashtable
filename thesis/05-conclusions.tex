\chapter{Conclusions} \label{Conclusion}

% \section{Overview}

The main goal of our thesis was to explore capabilities of \NVM in the context of distributed systems by designing and implementing a system called \DHTS. \DHTS is a NVM-enabled, highly available distributed hash table with tunable level of data replication.
The system was designed following the principles of Amazon Dynamo and uses a custom-built generic local hash table implementation built on top of the Intel's \libpmemobj library.

\tk{What should follow:
\begin{itemize}
    \item Briefly, how your system performs, 
    \item what are the pros and cons,
    \item what can be improved and how
    \item what you learned and if it was worthwhile)
    \item you can mention what has been most challenging
    \item please no corporate mumbo-jumbo talk about minimum value product
\end{itemize}}

As initial part of our work we gained knowledge about the \NVM and programming libraries for two purposes: NVM-support and distributed programming. 
We identified expected performance of NVM as located in between DRAM and Solid State Drive with possibilities for improvement in the future. 
For programming environment we have chosen C++ language with \PMDK. 
It is set of libraries developed by Intel Corporation that provides access to Persistent Memory.

The first step of developing our application was to create \PHT, an NVM-enabled, generic hashmap with support for concurrency.
Using \PMDK we created solution based on ConcurrentHashMap data structure in Java 7. 
It consists of several \internalHashMaps, each with its own readers-writers lock to provide high availability and thread-safety while accessed by multiple threads.
Then we performed some unit tests to validate our implementation's correctness, and performance tests to compare our product with other solutions.
As expected, operations on \PHT are slower, depending on test case 2 - 10 times than its DRAM counterpart.

As a second step of this project we developed distributed, decentralised system.
First version was based on \Seastar, but in final version we used \Asio due to problems with integration of \Seastar and \textit{PMDK}
The provided system consists of several \Nodes which are aware of other peers in network. 
To divide data between \Nodes we use concept of \textit{consistent hashing}.
It assigns every peer in network some range of hash ring based on result on hash function of its port and IP address. 
That range may change over time as more nodes connect to the network.
In the final product every \Node stores data assigned to it in its internal \PHT. 

Next step was to merge parts created in previous steps together, to acquire \DHTS in result. 
During this operation we encountered the problem with using \Seastar and \textit{PMDK} within one application, so we decide to change used technology to \Asio. 
When we solved the described problem we added an instance of \PHT to every Node, as stated above, and implemented \texttt{add}, \texttt{remove} and \texttt{get} operations on the system.

\section{Development opportunities}

We have developed Minimum Value Product which offers basic functionality. 
There are several ways of possible improvement.

In current version of our system situations when \Node disconnects from the network are not fully supported.
When it reconnects before being requested by any of its peers it does not cause any negative impact on the \DHTS. 
However, since such requests may leave system in inconsistent state, the failure detection system should be improved.

\DHTS does not provide a method which allows to get global state of the hashmap. 
Each node has ability to iterate through elements it stores, but system does not allow to collect such data from all nodes.

Because of the nature of distributed systems the communication between the nodes is asynchronous which means that requests created earlier may be handled after their successors.
Therefore a mechanism resolving such situations could be implemented.
Requests modifying the same elements in a short period of time are called collisions.
The most popular solution to this problem in high-available system is based on using timestamps.
This allows system to determine which operations order.
To ensure the correctness of the \texttt{remove} method in described solution tombstones need to be implemented.
They are flags used to mark which elements were in the \PHT and were deleted and should not be added during a conflict resolution.
This approach is crucial when node reconnects to the network after a period of absence.

What is more, conducting performance tests of provided system using hardware \PM solution could lead to interesting insights.
Results of those tests would show current performance and usability of NVM technology. 

% Zakończenie pracy zwane również Uwagami końcowymi lub Podsumowaniem powinno zawierać ustosunkowanie
% się autora do zadań wskazanych we wstępie do pracy, a w szczególności do celu i zakresu pracy oraz
% porównanie ich z faktycznymi wynikami pracy. Podejście takie umożliwia jasne określenie stopnia
% realizacji założonych celów oraz zwrócenie uwagi na wyniki osiągnięte przez autora w ramach jego
% samodzielnej pracy.

% Integralną częścią pracy są również dodatki, aneksy i załączniki np.~płyty CDROM
% zawierające stworzone w ramach pracy programy, aplikacje i projekty.
